dnorm(c(-3,-2,-1,0,1,2,3))
sample(1:10, size=3)
z = seq(-6, 6, by = 0.01)
pdf = dnorm(z)
plot(x=z, y=pdf)
# cdf given a z-score
pnorm(0)
#fill a matrix by columns (default):
matrix(x = 1:12, nrow = 3, ncol = 4)
?matrix
#fill a matrix by columns (default):
matrix(data = 1:12, nrow = 3, ncol = 4)
# Check if sum of uniforms is normal
matrix(data = runif(12*10^5), nrow = 12, ncol = 10^5)
TwelveUniforms
# Check if sum of uniforms is normal
TwelveUniforms = matrix(data = runif(12*10^5), nrow = 12, ncol = 10^5)
SumOf12Uniforms = colSums(TwelveUniforms)
hist(SumOf12Uniforms)
hist(TwelveUniforms[1,])
# Check if sum of normal squares is chi-squared
N = 5
NNormals = matrix(data = rnorm(N*10^5), nrow = N, ncol = 10^5)
SumOfNSquaredNormals = colSums(NNormals^2)
hist(SumOfNSquaredNormals)
hist(SumOfNSquaredNormals, 50)
# Check if sum of LOTS of normal squares is closer to normal
N = 1000
NNormals = matrix(data = rnorm(N*10^5), nrow = N, ncol = 10^5)
SumOfNSquaredNormals = colSums(NNormals^2)
hist(SumOfNSquaredNormals, 50)
# Check if sum of normal squares is chi-squared
N1 = 5
NNormals = matrix(data = rnorm(N1*10^5), nrow = N1, ncol = 10^5)
SumOfNSquaredNormals = colSums(NNormals^2)
hist(SumOfNSquaredNormals, 50)
#Generate 10^5 random draws from a chi-squared
BultIn_ChiSq = rchisq(n = 10^5, df = N1)
hist(BultIn_ChiSq, 50, col = "red", add = TRUE)
library(ggplot2)
# Practice data
data(mpg, package = "ggplot2")
ggplot(data = mpg)
head(mpg)
ggplot(data = mpg, mapping = aes(x = displ, y = hwy))
g = ggplot(data = mpg, mapping = aes(x = displ, y = hwy))
g + geom_point()
# Aesthethics
g + geom_point(aes(color = class))
g + geom_point(aes(size = class))
g + geom_point(aes(shape = class))
g + geom_point(aes(alpha = class))
# Aesthethics: Color Brewer
library(RColorBrewer)
display.brewer.all()
display.brewer.pal(n = 3, name = "Blues")
display.brewer.pal(n = 4, name = "Blues")
display.brewer.pal(n = 5, name = "Blues")
g + geom_point(aes(color = class)) +
scale_color_brewer(palette = "Blues")
g + geom_point(aes(color = class)) +
scale_color_brewer(palette = "Greens")
g + geom_point(aes(color = class)) +
scale_color_brewer(palette = "Set1")
# Aesthethics: Shape (don't do from "Shape" on)
g + geom_point(aes(shape = class))
g + geom_point(aes(shape = class)) +
scale_shape_manual(values = 1:7)
g + geom_point(aes(shape = class)) +
scale_shape_manual(values = 1:7, name = "MyLegend")
# install.packages('ggplot2')
library(ggplot2)
# Practice Data ####
data(mpg,package = 'ggplot2')
head(mpg)
# First Plot ####
ggplot(data = mpg)
ggplot(data = mpg,mapping = aes(x = displ, y = hwy))
g = ggplot(data = mpg,mapping = aes(x = displ, y = hwy))
g + geom_point()
# Aesthetics ####
g + geom_point(aes(color = class))
g + geom_point(aes(size = class))
g + geom_point(aes(shape = class))
g + geom_point(aes(alpha = class))
# Aesthetics: Color ####
g + geom_point(mapping = aes(color = class))
g + geom_point(color = 'green')
g + geom_point(color = sample(c('blue','red'),nrow(mpg),T))
g + geom_point(color = sample(colors(),nrow(mpg),replace = T))
# Aesthetics: Color: Order ####
dsmall = diamonds[sample(nrow(diamonds),100),]
ggplot(dsmall, aes(x = price,y =  carat)) + geom_point(aes(color = cut))
diamond_cut_levels = levels(dsmall$cut)
n = length(diamond_cut_levels)
levels(dsmall$cut) = diamond_cut_levels[n:1]
ggplot(dsmall, aes(price, carat)) + geom_point(aes(color = cut))
# Aesthetics: Color Brewer####
# https://ggplot2.tidyverse.org/reference/scale_brewer.html
# https://rpubs.com/seslezak/color_schemes
# install.packages('RColorBrewer)
library(RColorBrewer)
display.brewer.all()
display.brewer.pal(n = 3, name = "Blues")
display.brewer.pal(n = 4, name = "Blues")
display.brewer.pal(n = 5, name = "Blues")
g + geom_point(aes(color = class)) +
scale_color_brewer(palette = 'Blues')
g + geom_point(aes(color = class)) +
scale_color_brewer(palette = 'Greens')
g + geom_point(aes(color = class)) +
scale_color_brewer(palette = 'Set1')
# Aesthetics: Shape ####
g + geom_point(aes(shape = class))
g + geom_point(aes(shape = class)) +
scale_shape_manual(values = 1:7)
g + geom_point(aes(shape = class)) +
scale_shape_manual(values = 1:7,name ='MyLegend')
g + geom_point(aes(shape = class)) +
scale_shape_manual(values = c('a','b','c','d','e','f','g'))
g + geom_point(aes(shape = class)) +
scale_shape_manual(values = c('*','.','$','%','?','0','~'))
g + geom_point(aes(shape = class, color = class))
g + geom_point(aes(shape = class)) + geom_point(aes(color = class))
# Themes ####
g + geom_point(aes(color = class))
g + geom_point(aes(color = class)) + theme()
g + geom_point(aes(color = class)) + theme_classic()
g + geom_point(aes(color = class)) + theme_bw()
g + geom_point(aes(color = class)) + theme_dark()
g + geom_point(aes(color = class)) + theme_void()
# Facets ####
g + geom_point() + facet_grid(. ~ cyl)
g + geom_point() + facet_grid(drv ~ .)
g + geom_point() + facet_grid(drv ~ cyl)
g + geom_point() + facet_wrap( ~ class)
g + geom_point() + facet_grid(drv ~ cyl)
g + geom_point() + facet_wrap( ~ class)
# Geometries: Smoothing ####
g + geom_point() + geom_smooth(se = FALSE)
# Geometries: Box Plots ####
g = ggplot(data = mpg, aes(x = class, y = hwy))
g + geom_boxplot()
g = ggplot(data = mpg, aes(x = reorder(class,hwy,median), y = hwy))
g = ggplot(data = mpg, aes(x = reorder(class,hwy,median), y = hwy))
# Geometries: Box Plots ####
g = ggplot(data = mpg, aes(x = class, y = hwy))
g + geom_boxplot()
g = ggplot(data = mpg, aes(x = reorder(class,hwy,median), y = hwy))
g + geom_boxplot()
# Geometries: Box Bars ####
g = ggplot(data = mpg,aes(x = drv))
g + geom_bar()
g + geom_bar(aes(fill = drv))
g + geom_bar(aes(fill = drv))
g + geom_bar(aes(fill = fl))
g + geom_bar(aes(fill = model))
g + geom_bar(aes(fill = fl))
g + geom_bar(aes(fill = fl), position = 'fill')
g + geom_bar(aes(fill = fl), position = 'dodge')
# Geometries: Jitter ####
g = ggplot(data = mpg, aes(x = cty, y = hwy))
g + geom_point()
g + geom_jitter()
g + geom_jitter() # Remove overlap. Why?
# Geometries: Histogram ####
g = ggplot(data = mpg,aes(x = hwy))
g + geom_histogram()
g + geom_histogram(binwidth = 5)
g + geom_histogram(bins = 4)
# Geometries: Histogram: Multiple ####
g + geom_histogram() + facet_wrap(~drv)
# Geometries: Histogram: Multiple ####
g + geom_histogram() + facet_wrap(~drv) # Divide/Section data by another variable
g + geom_freqpoly() + facet_wrap(~drv)
g + geom_density() + facet_wrap(~drv)
g + geom_freqpoly(aes(color = drv))
g + geom_density(aes(color = drv))
# Geometries: Large Data ####
g = ggplot(data = diamonds, aes(x = carat, y = price))
g + geom_point()
g + geom_bin2d()
g + geom_point() + geom_density2d()
g + geom_smooth()
g + geom_smooth(aes(group = cut))
g + geom_smooth(aes(color = cut))
g + geom_smooth(aes(color = cut), se=F)
g + geom_smooth(aes(color = cut), se=F, method = 'lm')
g + geom_smooth(aes(color = cut), se=F, method = 'loess') #
# Large Data Aesthetics ####
g + geom_point(size = 1.0, alpha = 1.0)
# Large Data Aesthetics ####
g + geom_point(size = 1.0, alpha = 1.0)
g + geom_point(size = 0.5, alpha = 1.0)
g + geom_point(size = 1.0, alpha = 0.1)
g + geom_point(size = 0.5, alpha = 0.1)
install.packages("shiny")
library(shiny)
library(shiny)
# Updating on Windows is apparently tricky.
# A package called installr, which is only for Windows can be used to ease the process.
# installing/loading the package:
if(!require(installr)) {
install.packages("installr");
require(installr)
} #load / install+load installr
# using the package:
updateR()
# This will start the updating process of your R installation.
# It will check for newer versions, and if one is available, will guide you through the decisions you’d need to make.
# using the package:
updateR()
require(installr)
# using the package:
updateR()
install.packages("shiny")
runExample("01_hello")
library(shiny)
runExample("01_hello")
runExample()
runExample("01_hello")
# Source
runExample("02_text")
# Paquetes
Libraries <- c("readxl",      # read_excel
"xlsx",        # write.xlsx
"rstudioapi",  # getActiveDocumentContext
"lubridate",   # makedatetime, year, month,.., second
"ggplot2",     # ggplot
"data.table",  # Data manipulation (aggregation with . operator)
"zoo",         # rollapplyr
"tidyr",       # fill
"dplyr",       # group_by, select, mutate, slice_max
"na.tools"     # na.replace
)
# Instalación/cargue de paquetes
for (L in Libraries) {
eval(parse(text = (paste0("if (!require(",
L,
")) install.packages('",
L,
"')
library(",
L,
")"
)
)
)
)
}
# Ubicación archivos de origen
BaseDirPath <- dirname(getActiveDocumentContext()$path)
A <- matrix(c(1,2,3,4), 2,2, byrow = T)
A %*% A
A
A <- matrix(c(1,2,3,4), 2,2, byrow = T)
solve(A) %*% solve(A)
solve(A)^2
solve(A %*% A)
B <- matrix(c(5,6,7,8), 2,2, byrow = T)
C <- solve(A+B)
C
D <- solve(A) - (solve(I + (solve(A) %*% B)) %*% solve(A) %*% B %*% solve(A))
I <- matrix(c(1,0,0,1), 2,2, byrow = T)
D <- solve(A) - (solve(I + (solve(A) %*% B)) %*% solve(A) %*% B %*% solve(A))
C
D <- solve(A) - (solve(I + (solve(A) %*% B)) %*% solve(A) %*% B %*% solve(A))
D
2*A%*%B - A%*%2*B
2*A%*%B
(2*A)%*%B - A%*%(2*B)
# 00. DESCRIPCIÓN E INSTRUCCIONES #############################################
# 0.1 Objetivo
# Calcular la señal de la estrategia (óptima o deseada) y sus estadísticas de
# retorno y riesgo a partir de serie histórica OHLC (apertura, máximo, mínimo y
# cierre) y un árbol de decisión de estrategias. El algoritmo de decisiones toma
# como base las señales calculadas bajo un principio de monto de inversión
# constante con apalancamiento en caso de requerirse.
# 0.2 Supuestos
# 0.2.1 Se realizan operaciones a las que haya lugar después de formación de la
#       vela de mercado para cada franja horaria (FH), teniendo en cuenta el
#       periodo de tiempo permitido de operación definido para cada día, el cual
#       excluye las franjas horarias que se consideran de baja liquidez.
# 0.2.2 Todas las franjas horarias se tienen en cuenta para el cálculo de la
#       señal intradiaria pero no para el cálculo de la vela diaria y por lo tanto
#       de los fractales intradiarios de referencia.
# 0.2.4 Para los cálculos de valoración, siempre se asumen posiciones largas.
# 0.2.5 Para los cálculos de retornos, se tiene en cuenta si la posición
#       realmente es larga o corta.
# 0.2.6 Se consigue operar en el mercado a los precios de cierre de la franja,
#       con costos transaccionales asociados a un bid-ask spread nulo.
# 0.2.7 El retorno objetivo empleado para el cálculo de la razón de Sortino
#       corresponde al de la tasa libre de riesgo (US Treasury 1-3y).
# 0.3 Instrucciones
# 0.3.1 Guardar con el nombre "Data NOMBREACTIVO.xlsx" el archivo que contiene
#       los insumos en la misma ruta donde se encuentra ubicado el código
#       "Estrategia y estadísticas NOMBREACTIVO (propuesto).R". Estos
#       insumos incluyen:
#       - Hoja "OHLC Activo": histórico de precios OHLC del activo.
#       - Hoja "OHLC libre de riesgo": histórico de precios OHLC del activo
#                                      empleado para calcular el retorno objetivo
#                                      en el cálculo de la razón de Sharpe
#                                      (y como retorno objetivo en la razón de Sortino).
#       - Hoja "N_FH_por_dia": número de FH de negociación a considerar en cada día.
#       - Hoja "N_FH_Cierre_Descartadas": número de FH descartadas para negociar
#                                         antes del cierre.
#       - Hoja "U_MDD_Objetivo": valor objetivo de la razón Utilidad/MDD empleado
#                                para visualizar solo la información de las
#                                estrategias que cumplan con esta condición.
#       - Hoja "RA_MDD_Objetivo": valor objetivo de la razón RetornoAnual/MDD
#                                 empleado para visualizar solo la información
#                                 de las estrategias que cumplan con esta condición.
#       - Hoja "VentanaMovilVol": periodo de tiempo (en días) a considerar para
#                                 el cálculo de las volatilidades.
#       - Hoja "Significancia": nivel de siginificancia deseado para los cálculos
#                               de VaR y CVaR.
#       El nombre del archivo de Excel debe asignarse a la variable "ArchivoCargue",
#       modificando la primera línea de código en la sección "02. LECTURA Y
#       PREPARACIÓN DE DATOS". Se debe verificar que las hojas solo contengan la
#       información mencionada y nada adicional (incluso celdas borradas).
# 0.3.2 Guardar en la misma ruta y con el nombre con el nombre "Parametros fractales.xlsx",
#       el archivo que contiene las reglas y variables que se emplean para las
#       condiciones de compra y venta de cada una de las estrategias diarias e
#       intradiarias, así comode la estrategia intradiaria de referencia, que
#       debe quedar en el última fila del archivo. Se debe verificar que el
#       archivo solo contenga la información mencionada y nada adicional
#       (incluso celdas borradas).
# 0.3.3 La última sección del código permite visualizar la información y
#       estadísticas de una estrategia en particular.
# 01. PAQUETES Y CONFIGURACIONES ##############################################
# Paquetes
Libraries <- c("readxl",      # read_excel
"openxlsx",    # createWorkbook, addWorksheet, writeData, saveWorkbook
"rstudioapi",  # getActiveDocumentContext
"lubridate",   # makedatetime, year, month,.., second
"ggplot2",     # ggplot
"data.table",  # Data manipulation (aggregation with . operator)
"zoo",         # rollapplyr, rollapply
"tidyr",       # fill
"dplyr",       # group_by, select, mutate, slice_max
"na.tools"     # na.replace
)
# Instalación/cargue de paquetes
for (L in Libraries) {
eval(parse(text = (paste0("if (!require(",
L,
")) install.packages('",
L,
"')
library(",
L,
")"
)
)
)
)
}
# Ubicación archivos de origen
BaseDirPath <- dirname(getActiveDocumentContext()$path)
setwd(BaseDirPath)
# Borrado de información
rm(list = ls())
#Plantillas para gráficos
PlantillaG <- theme(plot.title = element_text(color = "grey20", angle = 0, hjust = 0.5, vjust = 0.5, face = "bold", margin = margin(b = 20)),
plot.subtitle = element_text(color = "grey20", angle = 0, hjust = 0.5, vjust = 0.5, face = "bold", margin = margin(b = 20)),
axis.text.x = element_text(color = "grey20", size = 10, angle = 90, hjust = 0.5, vjust = 0.5, face = "plain", margin = margin(t = 5)),
axis.text.y = element_text(color = "grey20", angle = 0, hjust = 0.5, vjust = 0.5, face = "plain", margin = margin(r = 5)),
axis.title.x = element_text(color = "grey20", angle = 0, hjust = 0.5, vjust = 0.5, face = "plain", margin = margin(t = 10)),
axis.title.y = element_text(color = "grey20", angle = 90, hjust = 0.5, vjust = 0.5, face = "plain", margin = margin(r = 10)),
axis.ticks = element_blank(),
legend.position = "bottom", legend.title = element_text(face = "bold"), legend.text = element_text(size = 10), #legend.direction = "vertical", legend.box = "horizontal", #legend.key.size = unit(1, "cm"),
panel.background = element_blank(),
panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank(),
panel.grid.major.y = element_line(size=0.5, color = "lightgrey"),
panel.grid.minor.y = element_blank(),
panel.border = element_blank(),
axis.line.x = element_line(size=0.5, color = "grey")
)
?read_excel
# 00. DESCRIPCIÓN E INSTRUCCIONES #############################################
# 0.1 Objetivo
# Calcular la señal de la estrategia (óptima o deseada) y sus estadísticas de
# retorno y riesgo a partir de serie histórica OHLC (apertura, máximo, mínimo y
# cierre) y un árbol de decisión de estrategias. El algoritmo de decisiones toma
# como base las señales calculadas bajo un principio de monto de inversión
# constante con apalancamiento en caso de requerirse.
# 0.2 Supuestos
# 0.2.1 Se realizan operaciones a las que haya lugar después de formación de la
#       vela de mercado para cada franja horaria (FH), teniendo en cuenta el
#       periodo de tiempo permitido de operación definido para cada día, el cual
#       excluye las franjas horarias que se consideran de baja liquidez.
# 0.2.2 Todas las franjas horarias se tienen en cuenta para el cálculo de la
#       señal intradiaria pero no para el cálculo de la vela diaria y por lo tanto
#       de los fractales intradiarios de referencia.
# 0.2.4 Para los cálculos de valoración, siempre se asumen posiciones largas.
# 0.2.5 Para los cálculos de retornos, se tiene en cuenta si la posición
#       realmente es larga o corta.
# 0.2.6 Se consigue operar en el mercado a los precios de cierre de la franja,
#       con costos transaccionales asociados a un bid-ask spread nulo.
# 0.2.7 El retorno objetivo empleado para el cálculo de la razón de Sortino
#       corresponde al de la tasa libre de riesgo (US Treasury 1-3y).
# 0.3 Instrucciones
# 0.3.1 Guardar con el nombre "Data NOMBREACTIVO.xlsx" el archivo que contiene
#       los insumos en la misma ruta donde se encuentra ubicado el código
#       "Estrategia y estadísticas NOMBREACTIVO (propuesto).R". Estos
#       insumos incluyen:
#       - Hoja "OHLC Activo": histórico de precios OHLC del activo.
#       - Hoja "OHLC libre de riesgo": histórico de precios OHLC del activo
#                                      empleado para calcular el retorno objetivo
#                                      en el cálculo de la razón de Sharpe
#                                      (y como retorno objetivo en la razón de Sortino).
#       - Hoja "N_FH_por_dia": número de FH de negociación a considerar en cada día.
#       - Hoja "N_FH_Cierre_Descartadas": número de FH descartadas para negociar
#                                         antes del cierre.
#       - Hoja "U_MDD_Objetivo": valor objetivo de la razón Utilidad/MDD empleado
#                                para visualizar solo la información de las
#                                estrategias que cumplan con esta condición.
#       - Hoja "RA_MDD_Objetivo": valor objetivo de la razón RetornoAnual/MDD
#                                 empleado para visualizar solo la información
#                                 de las estrategias que cumplan con esta condición.
#       - Hoja "VentanaMovilVol": periodo de tiempo (en días) a considerar para
#                                 el cálculo de las volatilidades.
#       - Hoja "Significancia": nivel de siginificancia deseado para los cálculos
#                               de VaR y CVaR.
#       El nombre del archivo de Excel debe asignarse a la variable "ArchivoCargue",
#       modificando la primera línea de código en la sección "02. LECTURA Y
#       PREPARACIÓN DE DATOS". Se debe verificar que las hojas solo contengan la
#       información mencionada y nada adicional (incluso celdas borradas).
# 0.3.2 Guardar en la misma ruta y con el nombre con el nombre "Parametros fractales.xlsx",
#       el archivo que contiene las reglas y variables que se emplean para las
#       condiciones de compra y venta de cada una de las estrategias diarias e
#       intradiarias, así comode la estrategia intradiaria de referencia, que
#       debe quedar en el última fila del archivo. Se debe verificar que el
#       archivo solo contenga la información mencionada y nada adicional
#       (incluso celdas borradas).
# 0.3.3 La última sección del código permite visualizar la información y
#       estadísticas de una estrategia en particular.
# 01. PAQUETES Y CONFIGURACIONES ##############################################
# Paquetes
Libraries <- c("readxl",      # read_excel
"openxlsx",    # createWorkbook, addWorksheet, writeData, saveWorkbook
"rstudioapi",  # getActiveDocumentContext
"lubridate",   # makedatetime, year, month,.., second
"ggplot2",     # ggplot
"data.table",  # Data manipulation (aggregation with . operator)
"zoo",         # rollapplyr, rollapply
"tidyr",       # fill
"dplyr",       # group_by, select, mutate, slice_max
"na.tools"     # na.replace
)
# Instalación/cargue de paquetes
for (L in Libraries) {
eval(parse(text = (paste0("if (!require(",
L,
")) install.packages('",
L,
"')
library(",
L,
")"
)
)
)
)
}
# Ubicación archivos de origen
BaseDirPath <- dirname(getActiveDocumentContext()$path)
setwd(BaseDirPath)
# Borrado de información
rm(list = ls())
#Plantillas para gráficos
PlantillaG <- theme(plot.title = element_text(color = "grey20", angle = 0, hjust = 0.5, vjust = 0.5, face = "bold", margin = margin(b = 20)),
plot.subtitle = element_text(color = "grey20", angle = 0, hjust = 0.5, vjust = 0.5, face = "bold", margin = margin(b = 20)),
axis.text.x = element_text(color = "grey20", size = 10, angle = 90, hjust = 0.5, vjust = 0.5, face = "plain", margin = margin(t = 5)),
axis.text.y = element_text(color = "grey20", angle = 0, hjust = 0.5, vjust = 0.5, face = "plain", margin = margin(r = 5)),
axis.title.x = element_text(color = "grey20", angle = 0, hjust = 0.5, vjust = 0.5, face = "plain", margin = margin(t = 10)),
axis.title.y = element_text(color = "grey20", angle = 90, hjust = 0.5, vjust = 0.5, face = "plain", margin = margin(r = 10)),
axis.ticks = element_blank(),
legend.position = "bottom", legend.title = element_text(face = "bold"), legend.text = element_text(size = 10), #legend.direction = "vertical", legend.box = "horizontal", #legend.key.size = unit(1, "cm"),
panel.background = element_blank(),
panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank(),
panel.grid.major.y = element_line(size=0.5, color = "lightgrey"),
panel.grid.minor.y = element_blank(),
panel.border = element_blank(),
axis.line.x = element_line(size=0.5, color = "grey")
)
?read_excel
# Variables y parámetros para los cálculos - Número de franjas horarias por día
NFHD <- as.numeric(read_excel(ArchivoCargue,
sheet = "Insumos",
range = "B1",
col_names = FALSE
)
)
# Lectura de archivo histórico de precios
ArchivoCargue <- "Data NOMBREACTIVO.xlsx"
# Variables y parámetros para los cálculos - Número de franjas horarias por día
NFHD <- as.numeric(read_excel(ArchivoCargue,
sheet = "Insumos",
range = "B1",
col_names = FALSE
)
)
# Variables y parámetros para los cálculos - Número de franjas horarias por día
NFHD <- as.numeric(read_excel(ArchivoCargue,
sheet = "Insumos",
range = "B1",
col_names = FALSE
)
)
