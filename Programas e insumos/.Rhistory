DesfaseNoBS <- 1
FunSenFDX_NoBS <- paste0("BDPD$", ParamFracD$Fractal, "_NoBS",
" <- shift(",
"x = ", "BDPD$", ParamFracD$Fractal,
", ",
"n = ", DesfaseNoBS,
", ",
"fill = NA",
")"
)
eval(parse(text = FunSenFDX_NoBS))
# Señal para cada fractal intradiario de referencia cuando no se cumplen las
# condiciones de "BUY" o "SELL".
# Importe de señal diaria empleada cuando no se cumplen las condiciones de
# "BUY" o "SELL", desde base de datos diaria a base de datos intradiaria.
# Ejemplo importe FD1_NoBS:
# BDPI$FD1_NoBS <- BDPD$FD1_NoBS[match(BDPI$DATE, BDPD$DATE)]
FunSenFDX_NoBS_I <- paste0("BDPI$", ParamFracD$Fractal, "_NoBS",
" <- BDPD$", ParamFracD$Fractal, "_NoBS",
"[match(as.Date(BDPI$DATE), BDPD$DATE)]"
)
eval(parse(text = FunSenFDX_NoBS_I))
# Ejemplo asignación a FIR1 de señal diaria empleada cuando no se cumplen las
# condiciones de "BUY" o "SELL":
# BDPI$FIR1 <- ifelse(is.na(BDPI$FIR1), BDPI$FD1_NoBS, BDPI$FIR1)
FunSenFIRX <- paste0("BDPI$", ParamFracR$Fractal,
" <- ifelse(",
"is.na(", "BDPI$", ParamFracR$Fractal, ")",
", ",
"BDPI$", ParamFracD$Fractal, "_NoBS",
", ",
"BDPI$", ParamFracR$Fractal,
")"
)
eval(parse(text = FunSenFIRX))
# 10. CÁLCULO SEÑAL INTRADIARIA FINAL (SIF) ###################################
# Listado de señales y nombres de sus posibles combinaciones
Senales <- data.frame(NombreBD = rep(NA, NFrac^2),
I = rep(1:NFrac,rep(NFrac, NFrac)),
R = rep(1:NFrac, NFrac),
FI = paste0("FI",rep(1:NFrac,rep(NFrac, NFrac))),
FIR = paste0("FIR", rep(1:NFrac, NFrac))
)
Senales$NombreBD <- paste0("BDP_I", Senales$I, "_R", Senales$R)
rownames(Senales) <- paste0("I", Senales$I, "R", Senales$R)
# Creación de base de datos para cada combinación de señales posible
FunBDPSList <- paste0(Senales$NombreBD,
" <- BDPI[",
"match(",
"c('DATE',",
"'DATEFRAME',",
"'VOLUME',",
"'OPEN',",
"'HIGH',",
"'LOW',",
"'CLOSE',",
"'", Senales$FI, "' ," ,
"'",  Senales$FIR, "'",
")",
",",
" colnames(BDPI)",
")",
"]"
)
eval(parse(text = FunBDPSList))
BDPSList <- lapply(Senales$NombreBD, get)
names(BDPSList) <- Senales$NombreBD
rm(list = Senales$NombreBD)
# Cálculo de señal Intradiaria Final (SIF)
FunSIF <- function(BD) {
colnames(BD)[match("FI", substr(colnames(BD),1,2))] <- "FI"
colnames(BD)[match("FIR", substr(colnames(BD),1,3))] <- "FIR"
BD$SIF <- ifelse(BD$FI == BD$FIR,BD$FI,"NONE")
BD$SIF[is.na(BD$SIF)] <- "NONE"
return(BD)
}
BDPSList <- lapply(BDPSList, FunSIF)
# 11. DECISIÓN DE INVERSIÓN ####
# Determinación de la decisión de inversión con base en los cambios en SIF
FunDecision <- function(BD) {
BD$DECISION <- ifelse((BD$SIF == shift(BD$SIF, n=1, fill = NA)),
ifelse((BD$SIF == "BUY" & shift(BD$SIF, n=1, fill = NA) == "BUY") | (BD$SIF == "SELL" & shift(BD$SIF, n=1, fill = NA) == "SELL"),
"HOLD POSITION",
"NO POSITION"
),
ifelse((shift(BD$SIF, n=1, fill = NA) == "NONE"),
"OPEN",
ifelse((BD$SIF == "NONE"),
"CLOSE",
"CLOSE-OPEN"
)
)
)
return(BD)
}
BDPSList <- lapply(BDPSList, FunDecision)
# 12. CÁLCULO POSICIÓN Y VALORACIÓN [PROPUESTA] ###############################
# Asignación de PENTRADA, PCIERRE y signos de posiciones cortas o largas para las señales
Fun_PENTRADA_PCIERRE_SENALSIGNO <- function(BD) {
# Asignación de precio de entrada (PENTRADA)
BD$PENTRADA <- ifelse((BD$DECISION == "OPEN"),
BD$CLOSE,
ifelse((BD$DECISION == "CLOSE-OPEN"),
BD$CLOSE,
NA
)
)
BD$PENTRADA <- na.locf(BD$PENTRADA, na.rm = FALSE) # Arrastre donde no es OPEN o CLOSE-OPEN
ID_CLOSEOPEN <- which(BD$DECISION=="CLOSE-OPEN")
BD$PENTRADA[ID_CLOSEOPEN] <- shift(BD$PENTRADA, n=1, fill=NA)[ID_CLOSEOPEN] # Para CLOSE-OPEN se deja el PA de la posición cerrada.
BD$PENTRADA[which(BD$DECISION == "NO POSITION")] <- NA # No aplica si no hay posición
# Asignación de precio de cierre (PCIERRE)
BD$PCIERRE <- ifelse((BD$DECISION == "CLOSE"),
BD$CLOSE,
ifelse((BD$DECISION == "CLOSE-OPEN"),
BD$CLOSE,
NA
)
)
# Asignación de signo según señal para identificar posiciones largas y cortas
BD$SENALSIGNO <- ifelse((BD$DECISION == "OPEN") | (BD$DECISION == "HOLD POSITION"),
ifelse((BD$SIF == "BUY"),
1,
-1
),
ifelse((BD$DECISION == "CLOSE") | (BD$DECISION == "CLOSE-OPEN"),
ifelse((shift(BD$SIF, n=1, fill=NA) == "BUY"),
1,
-1
),
0 # Cuando DECISION es "NO POSITION" o NA
)
)
BD$SENALSIGNO <- ifelse(is.na(BD$DECISION), 0, BD$SENALSIGNO)
#Resultados
return(BD)
}
BDPSList <- lapply(BDPSList, Fun_PENTRADA_PCIERRE_SENALSIGNO) # Construye lista de BDs
# Cálculo de posición y valoración del portafolio suponiendo solo posiciones largas
Fun_POS_VAL_PORT <- function(BD) {
# Valor de fondeo inicial
FONDEOINICIAL <- 100
# Columnas para precio de entrada (PENTRADA), volumen y valor de posición inicial
# y final (VOL_POSINICIAL, VOL_POSFINAL, VAL_POSINICIAL y VAL_POSFINAL), volumen
# y valor de compras y ventas (VOL_COMPRAS, VOL_VENTAS, VAL_COMPRAS y VAL_VENTAS).
# También se definen las variables de entrada conocidas, correspondientes a la
# primera FH de la serie.
BD$VOL_POSINICIAL <- NA
BD$VAL_POSINICIAL <- NA
BD$VOL_COMPRAS <- c(0, rep(NA, (N-1)))
BD$VAL_COMPRAS <- c(0, rep(NA, (N-1)))
BD$VOL_VENTAS <- c(0, rep(NA, (N-1)))
BD$VAL_VENTAS <- c(0, rep(NA, (N-1)))
BD$VOL_POSFINAL <- c(0, rep(NA, (N-1)))
BD$VAL_POSFINAL <- c(0, rep(NA, (N-1)))
BD$EFECTIVO <- c(FONDEOINICIAL, rep(NA, (N-1)))
BD$VAL_PORT <- c((BD$VOL_POSFINAL[1]*BD$CLOSE[1]+BD$EFECTIVO[1]), rep(NA, (N-1)))
for (t in 2:N) {
BD$VOL_POSINICIAL[t] <- BD$VOL_POSFINAL[t-1]
BD$VAL_POSINICIAL[t] <- BD$VAL_POSFINAL[t-1]
if (BD$DECISION[t] == "OPEN") { # Si decisiÓn es "OPEN"
BD$VAL_VENTAS[t] <- 0
BD$VOL_VENTAS[t] <- BD$VAL_VENTAS[t] / BD$PENTRADA[t]
BD$VAL_COMPRAS[t] <- BD$EFECTIVO[t-1]
BD$VOL_COMPRAS[t] <- BD$VAL_COMPRAS[t] / BD$PENTRADA[t]
} else { # Si decisiÓn NO es "OPEN"
if (BD$DECISION[t] == "CLOSE-OPEN") { # Si decisiÓn es "CLOSE-OPEN"
BD$VOL_VENTAS[t] <- BD$VOL_POSINICIAL[t]
BD$VAL_VENTAS[t] <- BD$VOL_VENTAS[t] * BD$PCIERRE[t]
BD$VAL_COMPRAS[t] <- BD$VAL_VENTAS[t]
BD$VOL_COMPRAS[t] <- BD$VAL_COMPRAS[t] / BD$CLOSE[t]
} else { # Si decisiÓn NO es "OPEN" ni "CLOSE-OPEN"
if (BD$DECISION[t] == "CLOSE") { # Si decisiÓn es "CLOSE"
BD$VOL_VENTAS[t] <- BD$VOL_POSINICIAL[t]
BD$VAL_VENTAS[t] <- BD$VOL_VENTAS[t] * BD$PCIERRE[t]
BD$VAL_COMPRAS[t] <- 0
BD$VOL_COMPRAS[t] <- 0
} else { # Si decisiÓn es NO "OPEN" ni "CLOSE-OPEN" ni "CLOSE"
if (BD$DECISION[t] == "HOLD POSITION") { # Si decisiÓn es "HOLD POSITION"
BD$VOL_VENTAS[t] <- 0
BD$VAL_VENTAS[t] <- 0
BD$VAL_COMPRAS[t] <- 0
BD$VOL_COMPRAS[t] <- 0
} else { # Si decisiÓn es "NO POSITION"
BD$VOL_VENTAS[t] <- 0
BD$VAL_VENTAS[t] <- 0
BD$VAL_COMPRAS[t] <- 0
BD$VOL_COMPRAS[t] <- 0
}
}
}
}
# Siempre se calcula la posición final y la valoración del efectivo y del portafolio:
BD$VOL_POSFINAL[t] <- BD$VOL_POSINICIAL[t] +
BD$VOL_COMPRAS[t] -
BD$VOL_VENTAS[t]
BD$VAL_POSFINAL[t] <- BD$VOL_POSFINAL[t] * BD$CLOSE[t]
BD$EFECTIVO[t] <- BD$EFECTIVO[t-1] + BD$VAL_VENTAS[t] - BD$VAL_COMPRAS[t]
BD$VAL_PORT[t] <- BD$VAL_POSFINAL[t] + BD$EFECTIVO[t]
}
#Resultados
return(BD)
}
StartT <- Sys.time()
BDPSList <- lapply(BDPSList, Fun_POS_VAL_PORT)
EndT <- Sys.time()
TElapsed <- EndT - StartT
save.image("D:/IDSG/Wissen/GitHub/Swell_2_Optimizacion_estrategias/Programas e insumos/Estrategia y estadísticas NOMBREACTIVO (propuesto) v0.0.RData")
BDPSList$BDP_I1_R1
View(BDPSList$BDP_I1_R1)
# 13. CÁLCULO ESTADÍSTICAS RETORNO Y RIESGO [PROPUESTA] #######################
Fun_Est_Riesgo_Retorno <- function(BD) {
# Columnas
BD$RET <- c(0, rep(NA, (N-1)))
BD$RET_ACUM <- c(0, rep(NA, (N-1)))
BD$VAL_PORT_ACUM_B100 <- c(100, rep(NA, (N-1)))
BD$PERD_ACUM <- c(0, rep(NA, (N-1)))
BD$MAX_PERD_ACUM <- c(0, rep(NA, (N-1)))
# Retorno de cada FH
BD$RET <- ((BD$VAL_PORT / c(0, BD$VAL_PORT[1:N-1]) - 1)) * c(NA, BD$SENALSIGNO[1:N-1])
# Retorno acumulado y acumulado base 100
BD$RET_ACUM <- c(NA, (cumprod(1 + BD$RET[2:N]) - 1))
BD$VAL_PORT_ACUM_B100 <- (BD$RET_ACUM + 1) * 100
# Pérdidad acumulada y máxima pérdida acumulada
BD$PERD_ACUM <- c(NA, (BD$VAL_PORT_ACUM_B100[2:N]) / (cummax(BD$VAL_PORT_ACUM_B100[2:N])) - 1)
BD$MAX_PERD_ACUM <- c(NA, cummin(BD$PERD_ACUM[2:N]))
# Estadísticas finales retorno y riesgo
RET_ACUM <- BD$RET_ACUM[N]
VAL_PORT_ACUM_B100 <- BD$VAL_PORT_ACUM_B100[N]
RET_ACUM_ANUAL <- (1 + RET_ACUM)^(365*(13-NFHC)/(N-1)) - 1
MAXPERDACUM <- BD$MAX_PERD_ACUM[N]
RA_MPA <- RET_ACUM_ANUAL / MAXPERDACUM
# Gráfico utilidad acumulada
G_RETACUM <- ggplot(BD, aes(x=DATE, y=VAL_PORT_ACUM_B100)) +
geom_line() +
ggtitle("Retorno acumulado (Base 100)") +
xlab("Fecha") + ylab("Retorno acumulado (Base 100)") +
expand_limits(x =BD$DATE[1]) +
expand_limits(y = 0) +
PlantillaG
#Resultados
BD_Est_Retorno_Riesgo <- list(BD, RET_ACUM_ANUAL, VAL_PORT_ACUM_B100, MAXPERDACUM, RA_MPA, G_RETACUM)
names(BD_Est_Retorno_Riesgo) <- c("BD", "RetAcumAnual", "VAlPortAcumB100", "MaxPerdAcum", "RA_MPA", "Graf_RetAcum")
return(BD_Est_Retorno_Riesgo)
}
BDPSList <- lapply(BDPSList, Fun_Est_Riesgo_Retorno) # Construye lista de listas
names(BDPSList) <- rownames(Senales)
View(BDPSList)
View(BDPSList$I1R1$BD)
# Función para obtención de estadísticas retorno y riesgo de cada estrategia
Fun_R_R <- function(List) {
R_R <- data.frame(RetAcumAnual = List$RetAcumAnual,
VAlPortAcumB100 = List$VAlPortAcumB100,
MaxPerdAcum = List$MaxPerdAcum,
RA_MPA = List$RA_MPA
)
return(R_R)
}
# Obtención de estadísticas retorno y riesgo de cada estrategia
Senales <- cbind(Senales, t(sapply(BDPSList, Fun_R_R)))
View(Senales)
Senales$RetAcum <- unlist(Senales$RetAcum)
Senales$ValAcumB100 <- unlist(Senales$ValAcumB100)
Senales$MaxPerdAcum <- unlist(Senales$MaxPerdAcum)
Senales$RA_MPA <- unlist(Senales$RA_MPA)
# Gráfico RetAcum/MDD por estrategia
ggplot(Senales, aes(x = rownames(Senales), y = RA_MPA)) +
geom_col() +
ggtitle("Ret.Acum/MDD por estrategia") +
xlab("Estrategia") + ylab("Ret.Acum/MDD") +
expand_limits(x = 0) +
expand_limits(y = 0) +
PlantillaG
# Gráfico RetAcum/MDD para estrategias por encima del promedio
Estrategias_Mayores_Media <-  Senales %>% filter(RA_MPA > mean(RA_MPA))
ggplot(Estrategias_Mayores_Media,
aes(x = reorder(rownames(Estrategias_Mayores_Media), RA_MPA), y = UA_MPA)) +
geom_col() +
ggtitle("Ret.Acum/MDD para estrategias por encima del promedio") +
xlab("Estrategia") + ylab("Ret.Acum/MDD") +
expand_limits(x = 0) +
expand_limits(y = 0) +
PlantillaG
RA_MDD_Objetivo <- as.numeric(read_excel(ArchivoCargue,
sheet = "RA_MDD_Objetivo",
col_names = FALSE
)
)
Estrategias_Mayores_Objetivo <-  Senales %>% filter(RA_MPA > RA_MDD_Objetivo)
ggplot(Estrategias_Mayores_Objetivo,
aes(x = reorder(rownames(Estrategias_Mayores_Objetivo), RA_MPA), y = RA_MPA)) +
geom_col() +
ggtitle("Ret.Acum/MDD para estrategias por encima del objetivo") +
xlab("Estrategia") + ylab("Ret.Acum/MDD") +
expand_limits(x = 0) +
expand_limits(y = 0) +
PlantillaG
# Gráfico RetAcum/MDD para estrategias por encima del promedio
Estrategias_Mayores_Media <-  Senales %>% filter(RA_MPA > mean(RA_MPA))
ggplot(Estrategias_Mayores_Media,
aes(x = reorder(rownames(Estrategias_Mayores_Media), RA_MPA), y = RA_MPA)) +
geom_col() +
ggtitle("Ret.Acum/MDD para estrategias por encima del promedio") +
xlab("Estrategia") + ylab("Ret.Acum/MDD") +
expand_limits(x = 0) +
expand_limits(y = 0) +
PlantillaG
RA_MDD_Objetivo <- as.numeric(read_excel(ArchivoCargue,
sheet = "RA_MDD_Objetivo",
col_names = FALSE
)
)
RA_MDD_Objetivo <- as.numeric(read_excel(ArchivoCargue,
sheet = "RA_MDD_Objetivo",
col_names = FALSE
)
)
Estrategias_Mayores_Objetivo <-  Senales %>% filter(RA_MPA > RA_MDD_Objetivo)
ggplot(Estrategias_Mayores_Objetivo,
aes(x = reorder(rownames(Estrategias_Mayores_Objetivo), RA_MPA), y = RA_MPA)) +
geom_col() +
ggtitle("Ret.Acum/MDD para estrategias por encima del objetivo") +
xlab("Estrategia") + ylab("Ret.Acum/MDD") +
expand_limits(x = 0) +
expand_limits(y = 0) +
PlantillaG
RA_MDD_Objetivo <- as.numeric(read_excel(ArchivoCargue,
sheet = "RA_MDD_Objetivo",
col_names = FALSE
)
)
Estrategias_Mayores_Objetivo <-  Senales %>% filter(RA_MPA > RA_MDD_Objetivo)
ggplot(Estrategias_Mayores_Objetivo,
aes(x = reorder(rownames(Estrategias_Mayores_Objetivo), RA_MPA), y = RA_MPA)) +
geom_col() +
ggtitle("Ret.Acum/MDD para estrategias por encima del objetivo") +
xlab("Estrategia") + ylab("Ret.Acum/MDD") +
expand_limits(x = 0) +
expand_limits(y = 0) +
PlantillaG
load("D:/IDSG/Wissen/GitHub/Swell_2_Optimizacion_estrategias/Programas e insumos/Estrategia y estadísticas NOMBREACTIVO (propuesto) v0.0.RData")
Fun_Est_Riesgo_Retorno <- function(BD) {
# Columnas
BD$RET <- c(0, rep(NA, (N-1)))
BD$RET_ACUM <- c(0, rep(NA, (N-1)))
BD$VAL_PORT_ACUM_B100 <- c(100, rep(NA, (N-1)))
BD$PERD_ACUM <- c(0, rep(NA, (N-1)))
BD$MAX_PERD_ACUM <- c(0, rep(NA, (N-1)))
# Retorno de cada FH
BD$RET <- ((BD$VAL_PORT / c(0, BD$VAL_PORT[1:N-1]) - 1)) * c(NA, BD$SENALSIGNO[1:N-1])
# Retorno acumulado y acumulado base 100
BD$RET_ACUM <- c(NA, (cumprod(1 + BD$RET[2:N]) - 1))
BD$VAL_PORT_ACUM_B100 <- (BD$RET_ACUM + 1) * 100
# Pérdidad acumulada y máxima pérdida acumulada
BD$PERD_ACUM <- c(NA, (BD$VAL_PORT_ACUM_B100[2:N]) / (cummax(BD$VAL_PORT_ACUM_B100[2:N])) - 1)
BD$MAX_PERD_ACUM <- c(NA, cummin(BD$PERD_ACUM[2:N]))
# Estadísticas finales retorno y riesgo
RET_ACUM <- BD$RET_ACUM[N]
VAL_PORT_ACUM_B100 <- BD$VAL_PORT_ACUM_B100[N]
RET_ACUM_ANUAL <- (1 + RET_ACUM)^(365*(13-NFHC)/(N-1)) - 1
MAXPERDACUM <- BD$MAX_PERD_ACUM[N]
RA_MPA <- RET_ACUM_ANUAL / MAXPERDACUM
# Gráfico utilidad acumulada
G_RETACUM <- ggplot(BD, aes(x=DATE, y=VAL_PORT_ACUM_B100)) +
geom_line() +
ggtitle("Retorno acumulado (Base 100)") +
xlab("Fecha") + ylab("Retorno acumulado (Base 100)") +
expand_limits(x =BD$DATE[1]) +
expand_limits(y = 0) +
PlantillaG
#Resultados
BD_Est_Retorno_Riesgo <- list(BD, RET_ACUM_ANUAL, VAL_PORT_ACUM_B100, MAXPERDACUM, RA_MPA, G_RETACUM)
names(BD_Est_Retorno_Riesgo) <- c("BD", "RetAcumAnual", "VAlPortAcumB100", "MaxPerdAcum", "RA_MPA", "Graf_RetAcum")
return(BD_Est_Retorno_Riesgo)
}
BDPSList <- lapply(BDPSList, Fun_Est_Riesgo_Retorno) # Construye lista de listas
names(BDPSList) <- rownames(Senales)
# 14. RESUMEN ESTADÍSTICAS ESTRATEGIAS [PROPUESTA] ############################
# Función para obtención de estadísticas retorno y riesgo de cada estrategia
Fun_R_R <- function(List) {
R_R <- data.frame(RetAcumAnual = List$RetAcumAnual,
VAlPortAcumB100 = List$VAlPortAcumB100,
MaxPerdAcum = List$MaxPerdAcum,
RA_MPA = List$RA_MPA
)
return(R_R)
}
# Obtención de estadísticas retorno y riesgo de cada estrategia
Senales <- cbind(Senales, t(sapply(BDPSList, Fun_R_R)))
Senales$RetAcum <- unlist(Senales$RetAcum)
Senales$ValAcumB100 <- unlist(Senales$ValAcumB100)
Senales$MaxPerdAcum <- unlist(Senales$MaxPerdAcum)
Senales$RA_MPA <- unlist(Senales$RA_MPA)
# Gráfico RetAcum/MDD por estrategia
ggplot(Senales, aes(x = rownames(Senales), y = RA_MPA)) +
geom_col() +
ggtitle("Ret.Acum/MDD por estrategia") +
xlab("Estrategia") + ylab("Ret.Acum/MDD") +
expand_limits(x = 0) +
expand_limits(y = 0) +
PlantillaG
# Gráfico RetAcum/MDD para estrategias por encima del promedio
Estrategias_Mayores_Media <-  Senales %>% filter(RA_MPA > mean(RA_MPA))
ggplot(Estrategias_Mayores_Media,
aes(x = reorder(rownames(Estrategias_Mayores_Media), RA_MPA), y = RA_MPA)) +
geom_col() +
ggtitle("Ret.Acum/MDD para estrategias por encima del promedio") +
xlab("Estrategia") + ylab("Ret.Acum/MDD") +
expand_limits(x = 0) +
expand_limits(y = 0) +
PlantillaG
RA_MDD_Objetivo <- as.numeric(read_excel(ArchivoCargue,
sheet = "RA_MDD_Objetivo",
col_names = FALSE
)
)
Estrategias_Mayores_Objetivo <-  Senales %>% filter(RA_MPA > RA_MDD_Objetivo)
ggplot(Estrategias_Mayores_Objetivo,
aes(x = reorder(rownames(Estrategias_Mayores_Objetivo), RA_MPA), y = RA_MPA)) +
geom_col() +
ggtitle("Ret.Acum/MDD para estrategias por encima del objetivo") +
xlab("Estrategia") + ylab("Ret.Acum/MDD") +
expand_limits(x = 0) +
expand_limits(y = 0) +
PlantillaG
View(BDPSList$BDP_I1_R1)
View(BDPSList$I1R1$BD)
load("D:/IDSG/Wissen/GitHub/Swell_2_Optimizacion_estrategias/Programas e insumos/Estrategia y estadísticas NOMBREACTIVO (propuesto) v0.0.RData")
Fun_Est_Riesgo_Retorno <- function(BD) {
# Columnas
BD$RET <- c(0, rep(NA, (N-1)))
BD$RET_ACUM <- c(0, rep(NA, (N-1)))
BD$VAL_PORT_ACUM_B100 <- c(100, rep(NA, (N-1)))
BD$PERD_ACUM <- c(0, rep(NA, (N-1)))
BD$MAX_PERD_ACUM <- c(0, rep(NA, (N-1)))
# Retorno de cada FH
BD$RET <- ((BD$VAL_PORT / c(0, BD$VAL_PORT[1:N-1]) - 1)) * c(NA, BD$SENALSIGNO[1:N-1])
# Retorno acumulado y acumulado base 100
BD$RET_ACUM <- c(NA, (cumprod(1 + BD$RET[2:N]) - 1))
BD$VAL_PORT_ACUM_B100 <- (BD$RET_ACUM + 1) * 100
# Pérdidad acumulada y máxima pérdida acumulada
BD$PERD_ACUM <- c(NA, (BD$VAL_PORT_ACUM_B100[2:N]) / (cummax(BD$VAL_PORT_ACUM_B100[2:N])) - 1)
BD$MAX_PERD_ACUM <- c(NA, cummin(BD$PERD_ACUM[2:N]))
# Estadísticas finales retorno y riesgo
RET_ACUM <- BD$RET_ACUM[N]
VAL_PORT_ACUM_B100 <- BD$VAL_PORT_ACUM_B100[N]
RET_ACUM_ANUAL <- (1 + RET_ACUM)^(365*(13-NFHC)/(N-1)) - 1
MAXPERDACUM <- BD$MAX_PERD_ACUM[N]
RAA_MPA <- RET_ACUM_ANUAL / -MAXPERDACUM
# Gráfico utilidad acumulada
G_RETACUM <- ggplot(BD, aes(x=DATE, y=VAL_PORT_ACUM_B100)) +
geom_line() +
ggtitle("Retorno acumulado (Base 100)") +
xlab("Fecha") + ylab("Retorno acumulado (Base 100)") +
expand_limits(x =BD$DATE[1]) +
expand_limits(y = 0) +
PlantillaG
#Resultados
BD_Est_Retorno_Riesgo <- list(BD, RET_ACUM_ANUAL, VAL_PORT_ACUM_B100, MAXPERDACUM, RAA_MPA, G_RETACUM)
names(BD_Est_Retorno_Riesgo) <- c("BD", "RetAcumAnual", "VAlPortAcumB100", "MaxPerdAcum", "RAA_MPA", "Graf_RetAcum")
return(BD_Est_Retorno_Riesgo)
}
BDPSList <- lapply(BDPSList, Fun_Est_Riesgo_Retorno) # Construye lista de listas
names(BDPSList) <- rownames(Senales)
# 14. RESUMEN ESTADÍSTICAS ESTRATEGIAS [PROPUESTA] ############################
# Función para obtención de estadísticas retorno y riesgo de cada estrategia
Fun_R_R <- function(List) {
R_R <- data.frame(RetAcumAnual = List$RetAcumAnual,
VAlPortAcumB100 = List$VAlPortAcumB100,
MaxPerdAcum = List$MaxPerdAcum,
RAA_MPA = List$RAA_MPA
)
return(R_R)
}
# Obtención de estadísticas retorno y riesgo de cada estrategia
Senales <- cbind(Senales, t(sapply(BDPSList, Fun_R_R)))
Senales$RetAcum <- unlist(Senales$RetAcum)
Senales$ValAcumB100 <- unlist(Senales$ValAcumB100)
Senales$MaxPerdAcum <- unlist(Senales$MaxPerdAcum)
Senales$RAA_MPA <- unlist(Senales$RAA_MPA)
# Gráfico RetAcum/MDD por estrategia
ggplot(Senales, aes(x = rownames(Senales), y = RAA_MPA)) +
geom_col() +
ggtitle("Ret.Acum/MDD por estrategia") +
xlab("Estrategia") + ylab("Ret.Acum/MDD") +
expand_limits(x = 0) +
expand_limits(y = 0) +
PlantillaG
# Gráfico RetAcum/MDD para estrategias por encima del promedio
Estrategias_Mayores_Media <-  Senales %>% filter(RAA_MPA > mean(RAA_MPA))
ggplot(Estrategias_Mayores_Media,
aes(x = reorder(rownames(Estrategias_Mayores_Media), RAA_MPA), y = RAA_MPA)) +
geom_col() +
ggtitle("Ret.Acum/MDD para estrategias por encima del promedio") +
xlab("Estrategia") + ylab("Ret.Acum/MDD") +
expand_limits(x = 0) +
expand_limits(y = 0) +
PlantillaG
RA_MDD_Objetivo <- as.numeric(read_excel(ArchivoCargue,
sheet = "RA_MDD_Objetivo",
col_names = FALSE
)
)
Estrategias_Mayores_Objetivo <-  Senales %>% filter(RAA_MPA > RA_MDD_Objetivo)
ggplot(Estrategias_Mayores_Objetivo,
aes(x = reorder(rownames(Estrategias_Mayores_Objetivo), RAA_MPA), y = RAA_MPA)) +
geom_col() +
ggtitle("Ret.Acum/MDD para estrategias por encima del objetivo") +
xlab("Estrategia") + ylab("Ret.Acum/MDD") +
expand_limits(x = 0) +
expand_limits(y = 0) +
PlantillaG
