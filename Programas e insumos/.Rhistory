# Asignación de títulos a las columnas
colnames(BDPI) <- c("DATE","FRAME","VOLUME","OPEN","HIGH","LOW","CLOSE")
# Reorganizacion de fechas y franjas horarias
BDPI$DATEFRAME <- make_datetime(year = year(BDPI$DATE),
month = month(BDPI$DATE),
day = day(BDPI$DATE),
hour = hour(BDPI$FRAME),
min = minute(BDPI$FRAME),
sec = second(BDPI$FRAME)
)
BDPI[,c("DATE","FRAME")] <- NULL
BDPI <- BDPI[,c("DATEFRAME","VOLUME","OPEN","HIGH","LOW","CLOSE")]
# Tamaño y ordenamiento de datos
N <- length(BDPI$DATEFRAME)
BDPI <- BDPI[order(BDPI$DATEFRAME),]
# 03. CODIFICACIÓN DE FRACTALES INTRADIARIOS ##################################
# Insumos parametrización FI
ParamFracI <- read_excel(ArchivoFractales, sheet = "Parametros fractales")
NFrac <- length(ParamFracI$Estrategia) - 1 # Número de fractales (se asume que la última fila corresponde a FIRX)
ParamFracI <- ParamFracI[-(NFrac+1),] # Eliminación de parámetros del fractal intradiario de referencia
# Variables de codificación de fractales intradiarios
ParamFracI$VentanaMovil <- ParamFracI$`Periodo fin` - ParamFracI$`Periodo inicio` + 1
ParamFracI$Desfase <- -ParamFracI$`Periodo fin`
ParamFracI$Fractal <- paste0("FI", ParamFracI$Estrategia)
ParamFracI$NombreRefCompra <- paste0(ParamFracI$Fractal,
"_B_",
ParamFracI$`Función compra`,
"_",
ParamFracI$`Ref. compra`,
"_",
-ParamFracI$`Periodo inicio`,
"_",
-ParamFracI$`Periodo fin`
)
ParamFracI$NombreRefVenta <- paste0(ParamFracI$Fractal,
"_S_",
ParamFracI$`Función venta`,
"_",
ParamFracI$`Ref. venta`,
"_",
-ParamFracI$`Periodo inicio`,
"_",
-ParamFracI$`Periodo fin`
)
ParamFracI$VariableCompra <- paste0("BDPI$",ParamFracI$`Variable compra`)
ParamFracI$RefCompra <- paste0("BDPI$",ParamFracI$`Ref. compra`)
ParamFracI$VariableVenta <- paste0("BDPI$",ParamFracI$`Variable venta`)
ParamFracI$RefVenta <- paste0("BDPI$",ParamFracI$`Ref. venta`)
# 04. CÁLCULO SEÑALES DE FRACTALES INTRADIARIOS ###############################
# Cálculo de la función sobre la referencia correspondiente a cada fractal
# intradiario de compra.Ejemplo FI1:
# BDPI$FI1_B_max_HIGH_4_1 <- rollapplyr(data = BDPI$HIGH, width = 4, FUN = max, fill = NA)
FunFracCompra <- paste0("BDPI$", ParamFracI$NombreRefCompra,
" <- rollapplyr(data = ", ParamFracI$RefCompra,
", width = ", ParamFracI$VentanaMovil,
", FUN = ", ParamFracI$`Función compra`, ", fill = NA)"
)
eval(parse(text = FunFracCompra))
# Aplicación del desfase de la ventana móvil correspondiente a cada fractal
# intradiario de compra.Ejemplo FI1:
# BDPI$FI1_B_max_HIGH_4_1 <- shift(x = BDPI$FI1_B_max_HIGH_4_1, n = 1, fill = NA)
FunDesfaseCompra <- paste0("BDPI$", ParamFracI$NombreRefCompra,
" <- shift(x = ", "BDPI$", ParamFracI$NombreRefCompra,
", n = ", ParamFracI$Desfase, ", fill = NA)"
)
eval(parse(text = FunDesfaseCompra))
# Cálculo de la función sobre la referencia correspondiente a cada fractal
# intradiario de venta. Ejemplo FI1:
# BDPI$FI1_S_min_LOW_4_1 <- rollapplyr(data = BDPI$LOW, width = 4, FUN = min, fill = NA)
FunFracVenta <- paste0("BDPI$", ParamFracI$NombreRefVenta,
" <- rollapplyr(data = ", ParamFracI$RefVenta,
", width = ", ParamFracI$VentanaMovil,
", FUN = ", ParamFracI$`Función venta`, ", fill = NA)"
)
eval(parse(text = FunFracVenta))
# Aplicación del desfase de la ventana móvil correspondiente a cada fractal
# intradiario de venta. Ejemplo FI1:
# BDPI$FI1_S_min_LOW_4_1 <- shift(x = BDPI$FI1_S_min_LOW_4_1, n = 1, fill = NA)
FunDesfaseVenta <-paste0("BDPI$", ParamFracI$NombreRefVenta,
" <- shift(x = ", "BDPI$", ParamFracI$NombreRefVenta,
", n = ", ParamFracI$Desfase, ", fill = NA)"
)
eval(parse(text = FunDesfaseVenta))
# Señal para condiciones de "BUY" o "SELL" en cada fractal intradiario. Ejemplo FI1:
# BDPI$FI1 <- ifelse (BDPI$CLOSE > BDPI$FI1_B_max_HIGH_4_1, "BUY", ifelse(BDPI$CLOSE < BDPI$FI1_S_min_LOW_4_1, "SELL", NA))
FunSenFIX <- paste0("BDPI$", ParamFracI$Fractal,
" <- ifelse(",
ParamFracI$VariableCompra, ParamFracI$`Criterio compra`, "BDPI$", ParamFracI$NombreRefCompra,
", 'BUY', ",
"ifelse(",
ParamFracI$VariableVenta, ParamFracI$`Criterio venta`, "BDPI$", ParamFracI$NombreRefVenta,
", 'SELL', ",
"NA",
")",
")"
)
eval(parse(text = FunSenFIX))
# Señal para cada fractal intradiario cuando no se cumplen las condiciones de "BUY" o "SELL".
BDPI <- fill(data = BDPI, ParamFracI$Fractal, .direction = "down")
# 05. ELIMINACIÓN FH DESCARTADAS ##############################################
BDPI$DATE <- NA
BDPI$DATE <- make_datetime(year = year(BDPI$DATEFRAME),
month = month(BDPI$DATEFRAME),
day = day(BDPI$DATEFRAME),
)
# Número de FH descartadas para negociar antes del cierre
NFHC <- as.numeric(read_excel(ArchivoInsumos,
sheet = "Insumos",
range = "B3",
col_names = FALSE
)
)
if (NFHC == 0) {
# No se elimina nada.
} else {
# FH del cierre de cada día seleccionadas para su eliminación
BD_Descartada <- BDPI %>% group_by(DATE) %>% slice_max(DATEFRAME, n = NFHC)
# Eliminación de FH seleccionadas
ID_FH_Descartadas <- match(BD_Descartada$DATEFRAME, BDPI$DATEFRAME)
BDPI <- BDPI[-ID_FH_Descartadas,]
}
N <- length(BDPI$DATEFRAME)
# 06. VELA DIARIA #############################################################
BDPD <- BDPI
BDPD$DATE <- as.Date(BDPD$DATEFRAME)
BDPD <- BDPD[,c("DATE","DATEFRAME","VOLUME","OPEN","HIGH","LOW","CLOSE")]
BDPD <- as.data.table(BDPD)
BDPD <- BDPD[,
.(VOLUME = sum(VOLUME),
OPEN = first(OPEN),
HIGH = max(HIGH),
LOW = min(LOW),
CLOSE = last(CLOSE)
),
by = "DATE"
]
# 07. CODIFICACIÓN DE FRACTALES DIARIOS (INCLUYE FIRX) ########################
# Variables de codificación de fractales diarios
ParamFracD <- read_excel(ArchivoFractales, sheet = "Parametros fractales")
# Insumos parametrización FIR
ParamFracD <- ParamFracD[-(NFrac+1),] # Eliminación de parámetros del fractal intradiario de referencia
ParamFracD[(NFrac+1):(NFrac*2),] <- ParamFracD[(1:NFrac),] # Réplica de parámetros de FIR
ParamFracD$VentanaMovil <- ParamFracD$`Periodo fin` - ParamFracD$`Periodo inicio` + 1
ParamFracD$Desfase <- -ParamFracD$`Periodo fin`
ParamFracD$Fractal <- paste0("FD", ParamFracD$Estrategia)
ParamFracD$NombreRefCompra <- paste0(ParamFracD$Fractal,
"_B_",
ParamFracD$`Función compra`,
"_",
ParamFracD$`Ref. compra`,
"_",
-ParamFracD$`Periodo inicio`,
"_",
-ParamFracD$`Periodo fin`
)
ParamFracD$NombreRefVenta <- paste0(ParamFracD$Fractal,
"_S_",
ParamFracD$`Función venta`,
"_",
ParamFracD$`Ref. venta`,
"_",
-ParamFracD$`Periodo inicio`,
"_",
-ParamFracD$`Periodo fin`
)
ParamFracD$VariableCompra <- paste0("BDPD$",ParamFracD$`Variable compra`)
ParamFracD$RefCompra <- paste0("BDPD$",ParamFracD$`Ref. compra`)
ParamFracD$VariableVenta <- paste0("BDPD$",ParamFracD$`Variable venta`)
ParamFracD$RefVenta <- paste0("BDPD$",ParamFracD$`Ref. venta`)
# Separación entre parámetros para FIR y para FD
LetraFIR <- "R" # Letra para identificación de fractales intradiarios de referencia
ParamFracD$Estrategia[(NFrac+1):(NFrac*2)] <- paste0(LetraFIR, (1:NFrac)) # Asignación de nombres de estrategias de referencia
ParamFracR <- ParamFracD[match(paste0(LetraFIR,(1:NFrac)),ParamFracD$Estrategia),]
ParamFracR$Fractal <- paste0("FI", ParamFracR$Estrategia) # Asignación de de nombres para FIRX
ParamFracD <- ParamFracD[-match(paste0(LetraFIR,(1:NFrac)),ParamFracD$Estrategia),] # Eliminación parámetros creados para FIRX en ParamFracD.
ParamFracR$VariableCompra <- paste0("BDPI$",ParamFracD$`Variable compra`)
ParamFracR$VariableVenta <- paste0("BDPI$",ParamFracD$`Variable venta`)
# 08. CÁLCULO SEÑALES DE FRACTALES DIARIOS ####################################
# Cálculo de la función sobre la referencia correspondiente a cada fractal
# diario de compra.Ejemplo FD1:
# BDPD$FD1_B_max_HIGH_4_1 <- rollapplyr(data = BDPD$HIGH, width = 4, FUN = max, fill = NA)
FunFracCompra <- paste0("BDPD$", ParamFracD$NombreRefCompra,
" <- rollapplyr(data = ", ParamFracD$RefCompra,
", width = ", ParamFracD$VentanaMovil,
", FUN = ", ParamFracD$`Función compra`, ", fill = NA)"
)
eval(parse(text = FunFracCompra))
# Aplicación del desfase de la ventana móvil correspondiente a cada fractal
# diario de compra.Ejemplo FD1:
# BDPD$FD1_B_max_HIGH_4_1 <- shift(x = BDPD$FD1_B_max_HIGH_4_1, n = 1, fill = NA)
FunDesfaseCompra <- paste0("BDPD$", ParamFracD$NombreRefCompra,
" <- shift(x = ", "BDPD$", ParamFracD$NombreRefCompra,
", n = ", ParamFracD$Desfase, ", fill = NA)"
)
eval(parse(text = FunDesfaseCompra))
# Cálculo de la función sobre la referencia correspondiente a cada fractal
# diario de venta. Ejemplo FD1:
# BDPD$FD1_S_min_LOW_4_1 <- rollapplyr(data = BDPD$LOW, width = 4, FUN = min, fill = NA)
FunFracVenta <- paste0("BDPD$", ParamFracD$NombreRefVenta,
" <- rollapplyr(data = ", ParamFracD$RefVenta,
", width = ", ParamFracD$VentanaMovil,
", FUN = ", ParamFracD$`Función venta`, ", fill = NA)"
)
eval(parse(text = FunFracVenta))
# Aplicación del desfase de la ventana móvil correspondiente a cada fractal
# diario de venta. Ejemplo FD1:
# BDPD$FD1_S_min_LOW_4_1 <- shift(x = BDPD$FD1_S_min_LOW_4_1, n = 1, fill = NA)
FunDesfaseVenta <- paste0("BDPD$", ParamFracD$NombreRefVenta,
" <- shift(x = ", "BDPD$", ParamFracD$NombreRefVenta,
", n = ", ParamFracD$Desfase, ", fill = NA)"
)
eval(parse(text = FunDesfaseVenta))
# Señal para condiciones de "BUY" o "SELL" en cada fractal diario. Ejemplo FD1:
# BDPD$FD1 <- ifelse (BDPD$CLOSE > BDPD$FD1_B_max_HIGH_4_1, "BUY", ifelse(BDPD$CLOSE < BDPD$FD1_S_min_LOW_4_1, "SELL", NA))
FunSenFDX <- paste0("BDPD$", ParamFracD$Fractal,
" <- ifelse(",
ParamFracD$VariableCompra, ParamFracD$`Criterio compra`, "BDPD$", ParamFracD$NombreRefCompra,
", 'BUY', ",
"ifelse(",
ParamFracD$VariableVenta, ParamFracD$`Criterio venta`, "BDPD$", ParamFracD$NombreRefVenta,
", 'SELL', ",
"NA",
")",
")"
)
eval(parse(text = FunSenFDX))
# Señal para cada fractal diario cuando no se cumplen las condiciones de "BUY" o "SELL".
BDPD <- fill(data = BDPD, ParamFracD$Fractal, .direction = "down")
# 09. CÁLCULO SEÑALES DE FRACTALES INTRADIARIOS DE REFERENCIA #################
# Importe a la base de datos intradiaria de la función sobre la referencia
# correspondiente a cada fractal diario de referencia de venta. Ejemplo FD1:
# BDPI$FD1_B_max_HIGH_4_1 <- BDPD$FD1_B_max_HIGH_4_1[match(as.Date(BDPI$DATE), BDPD$DATE)]
FunImporteFDCompra <- paste0("BDPI$", ParamFracR$NombreRefCompra,
" <- BDPD$", ParamFracR$NombreRefCompra,
"[match(as.Date(BDPI$DATE), BDPD$DATE)]"
)
eval(parse(text = FunImporteFDCompra))
# Importe a la base de datos intradiaria de la función sobre la referencia
# correspondiente a cada fractal diario de referencia de compra. Ejemplo FD1:
# BDPI$FD1_S_min_LOW_4_1 <- BDPD$FD1_S_min_LOW_4_1[match(as.Date(BDPI$DATE), BDPD$DATE)]
FunImporteFDVenta <- paste0("BDPI$", ParamFracR$NombreRefVenta,
" <- BDPD$", ParamFracR$NombreRefVenta,
"[match(as.Date(BDPI$DATE), BDPD$DATE)]"
)
eval(parse(text = FunImporteFDVenta))
# Señal para condiciones de "BUY" o "SELL" en cada fractal intradiario de
# referencia. Ejemplo FIR1:
# BDPI$FIR1 <- ifelse (BDPI$CLOSE > BDPI$FD1_B_max_HIGH_4_1, "BUY", ifelse(BDPI$CLOSE < BDPI$FD1_S_min_LOW_4_1, "SELL", NA))
FunSenFIRX_BS <- paste0("BDPI$", ParamFracR$Fractal,
" <- ifelse(",
ParamFracR$VariableCompra, ParamFracR$`Criterio compra`, "BDPI$", ParamFracR$NombreRefCompra,
", 'BUY', ",
"ifelse(",
ParamFracR$VariableVenta, ParamFracR$`Criterio venta`, "BDPI$", ParamFracR$NombreRefVenta,
", 'SELL', ",
"NA",
")",
")"
)
eval(parse(text = FunSenFIRX_BS))
# Aplicación de un desfase a cada fractal diario para su asignación a FIRX
# cuando no se cumplen las condiciones de "BUY" o "SELL". Ejemplo FD1_NoBS:
# BDPD$FD1_NoBS <- shift(x = BDPD$FD1, n = DesfaseNoBS, fill = NA)
DesfaseNoBS <- 1
FunSenFDX_NoBS <- paste0("BDPD$", ParamFracD$Fractal, "_NoBS",
" <- shift(",
"x = ", "BDPD$", ParamFracD$Fractal,
", ",
"n = ", DesfaseNoBS,
", ",
"fill = NA",
")"
)
eval(parse(text = FunSenFDX_NoBS))
# Señal para cada fractal intradiario de referencia cuando no se cumplen las
# condiciones de "BUY" o "SELL".
# Importe de señal diaria empleada cuando no se cumplen las condiciones de
# "BUY" o "SELL", desde base de datos diaria a base de datos intradiaria.
# Ejemplo importe FD1_NoBS:
# BDPI$FD1_NoBS <- BDPD$FD1_NoBS[match(BDPI$DATE, BDPD$DATE)]
FunSenFDX_NoBS_I <- paste0("BDPI$", ParamFracD$Fractal, "_NoBS",
" <- BDPD$", ParamFracD$Fractal, "_NoBS",
"[match(as.Date(BDPI$DATE), BDPD$DATE)]"
)
eval(parse(text = FunSenFDX_NoBS_I))
# Ejemplo asignación a FIR1 de señal diaria empleada cuando no se cumplen las
# condiciones de "BUY" o "SELL":
# BDPI$FIR1 <- ifelse(is.na(BDPI$FIR1), BDPI$FD1_NoBS, BDPI$FIR1)
FunSenFIRX <- paste0("BDPI$", ParamFracR$Fractal,
" <- ifelse(",
"is.na(", "BDPI$", ParamFracR$Fractal, ")",
", ",
"BDPI$", ParamFracD$Fractal, "_NoBS",
", ",
"BDPI$", ParamFracR$Fractal,
")"
)
eval(parse(text = FunSenFIRX))
# 10. CÁLCULO SEÑAL INTRADIARIA FINAL (SIF) ###################################
# Listado de señales y nombres de sus posibles combinaciones
Senales <- data.frame(NombreBD = rep(NA, NFrac^2),
I = rep(1:NFrac,rep(NFrac, NFrac)),
R = rep(1:NFrac, NFrac),
FI = paste0("FI",rep(1:NFrac,rep(NFrac, NFrac))),
FIR = paste0("FIR", rep(1:NFrac, NFrac))
)
Senales$NombreBD <- paste0("BDP_I", Senales$I, "_R", Senales$R)
rownames(Senales) <- paste0("I", Senales$I, "R", Senales$R)
# Creación de base de datos para cada combinación de señales posible
FunBDList <- paste0(Senales$NombreBD,
" <- BDPI[",
"match(",
"c('DATE',",
"'DATEFRAME',",
"'VOLUME',",
"'OPEN',",
"'HIGH',",
"'LOW',",
"'CLOSE',",
"'", Senales$FI, "' ," ,
"'",  Senales$FIR, "'",
")",
",",
" colnames(BDPI)",
")",
"]"
)
eval(parse(text = FunBDList))
BDList <- lapply(Senales$NombreBD, get)
names(BDList) <- Senales$NombreBD
rm(list = Senales$NombreBD)
# Cálculo de señal Intradiaria Final (SIF)
FunSIF <- function(BD) {
colnames(BD)[match("FI", substr(colnames(BD),1,2))] <- "FI"
colnames(BD)[match("FIR", substr(colnames(BD),1,3))] <- "FIR"
BD$SIF <- ifelse(BD$FI == BD$FIR,BD$FI,"NONE")
BD$SIF[is.na(BD$SIF)] <- "NONE"
return(BD)
}
BDList <- lapply(BDList, FunSIF)
# 11. DECISIÓN DE INVERSIÓN ####
# Determinación de la decisión de inversión con base en los cambios en SIF
FunDecision <- function(BD) {
BD$DECISION_SIF <- ifelse((BD$SIF == shift(BD$SIF, n=1, fill = NA)),
ifelse((BD$SIF == "BUY" & shift(BD$SIF, n=1, fill = NA) == "BUY") | (BD$SIF == "SELL" & shift(BD$SIF, n=1, fill = NA) == "SELL"),
"HOLD POSITION",
"NO POSITION"
),
ifelse((shift(BD$SIF, n=1, fill = NA) == "NONE"),
"OPEN",
ifelse((BD$SIF == "NONE"),
"CLOSE",
"CLOSE-OPEN"
)
)
)
return(BD)
}
BDList <- lapply(BDList, FunDecision)
BD <-  BDList$BDP_I1_R1
BAS <- as.numeric(read_excel(ArchivoInsumos,
sheet = "Insumos",
range = "B12",
col_names = FALSE
)
)
Comision <- as.numeric(read_excel(ArchivoInsumos,
sheet = "Insumos",
range = "B13",
col_names = FALSE
)
)
Zona_PG_Cierre <- read_excel(ArchivoInsumos,
sheet = "Zona_PG_Cierre",
range = "A1:D5",
col_names = TRUE
)
Zona_PG_Cierre$MinimoRazon[1] <- -Inf
Zona_PG_Cierre$MaximoRazon[length(Zona_PG_Cierre$MinimoRazon)] <- Inf
BD$PENTRADA <- ifelse((BD$DECISION_SIF == "OPEN"),
BD$CLOSE,
ifelse((BD$DECISION_SIF == "CLOSE-OPEN"),
BD$CLOSE,
NA
)
)
BD$PENTRADA <- na.locf(BD$PENTRADA, na.rm = FALSE) # Arrastre donde no es OPEN o CLOSE-OPEN
ID_CLOSEOPEN <- which(BD$DECISION_SIF=="CLOSE-OPEN")
BD$PENTRADA[ID_CLOSEOPEN] <- shift(BD$PENTRADA, n=1, fill=NA)[ID_CLOSEOPEN] # Para CLOSE-OPEN se deja el PA de la posición cerrada.
BD$PENTRADA[which(BD$DECISION_SIF == "NO POSITION")] <- NA # No aplica si no hay posición
# Asignación de precio de cierre (PCIERRE)
BD$PCIERRE <- ifelse((BD$DECISION_SIF == "CLOSE"),
BD$CLOSE,
ifelse((BD$DECISION_SIF == "CLOSE-OPEN"),
BD$CLOSE,
NA
)
)
# Asignación de signo según señal para identificar posiciones largas y cortas
BD$SENALSIGNO <- ifelse((BD$DECISION_SIF == "OPEN") | (BD$DECISION_SIF == "HOLD POSITION"),
ifelse((BD$SIF == "BUY"),
1,
-1
),
ifelse((BD$DECISION_SIF == "CLOSE") | (BD$DECISION_SIF == "CLOSE-OPEN"),
ifelse((shift(BD$SIF, n=1, fill=NA) == "BUY"),
1,
-1
),
0 # Cuando DECISION es "NO POSITION" o NA
)
)
BD$SENALSIGNO <- ifelse(is.na(BD$DECISION_SIF), 0, BD$SENALSIGNO)
# Cálculo de razones para SL y TP
BD$PA_PE <- ifelse(BD$DECISION_SIF == "HOLD POSITION",
(BD$OPEN / BD$PENTRADA - 1) * BD$SENALSIGNO,
NA
)
BD$PmaxPmin_PE <- ifelse(BD$DECISION_SIF == "HOLD POSITION",
ifelse(BD$SIF == "BUY",
(BD$LOW / BD$PENTRADA - 1) * BD$SENALSIGNO,
(BD$HIGH / BD$PENTRADA - 1) * BD$SENALSIGNO
),
NA
)
View(Zona_PG_Cierre)
BD$ZONA_PG_PA <- cut(x = BD$PA_PE,
breaks = c(Zona_PG_Cierre$MinimoRazon, Inf),
labels = Zona_PG_Cierre$Zona_PG
)
BD$ZONA_PG_PmaxPmin <- cut(x = BD$PmaxPmin_PE,
breaks = c(Zona_PG_Cierre$MinimoRazon, Inf),
labels = Zona_PG_Cierre$Zona_PG
)
BD$CIERRE_PA <- -Zona_PG_Cierre$Cierre[match(BD$ZONA_PG_PA, Zona_PG_Cierre$Zona_PG)]
BD$CIERRE_PmaxPmin <- -Zona_PG_Cierre$Cierre[match(BD$ZONA_PG_PmaxPmin, Zona_PG_Cierre$Zona_PG)]
BD$CIERREPARCIAL <- ifelse((BD$CIERRE_PA + BD$CIERRE_PmaxPmin) < -1,
-1,
(BD$CIERRE_PA + BD$CIERRE_PmaxPmin)
)
BD$CIERRE_ACUM <- ave(BD$CIERREPARCIAL,
cumsum(is.na(BD$CIERREPARCIAL) != c(T,is.na(BD$CIERREPARCIAL)[1:N-1])),
FUN = cumsum
)
View(as.data.frame(cumsum(is.na(BD$CIERREPARCIAL) != c(T,is.na(BD$CIERREPARCIAL)[1:N-1]))))
View(as.data.frame(cumsum(is.na(BD$CIERREPARCIAL)))))
View(as.data.frame(cumsum(is.na(BD$CIERREPARCIAL))))
View(as.data.frame(is.na(BD$CIERREPARCIAL) != c(T,is.na(BD$CIERREPARCIAL)[1:N-1]))
View(as.data.frame(is.na(BD$CIERREPARCIAL) != c(T,is.na(BD$CIERREPARCIAL)[1:N-1])))
BD$CIERRE_ACUM <- ave(BD$CIERREPARCIAL,
cumsum(is.na(BD$CIERREPARCIAL) != c(T,is.na(BD$CIERREPARCIAL)[1:N-1])), # Vector de grupos (se construye haciendo el cumsum de un vextor con VERDADERO en puntos de inicio)
FUN = cumsum
)
BD$CIERRE_ACUM <- ifelse(BD$CIERRE_ACUM < -1,
-1,
BD$CIERRE_ACUM
)
# Acumulado irrestricto de cierres parciales (SON ajuste por valores menores a -1)
BD$CIERRE_ACUM <- ave(BD$CIERREPARCIAL,
cumsum(is.na(BD$CIERREPARCIAL) != c(T,is.na(BD$CIERREPARCIAL)[1:N-1])), # Vector de grupos (se construye haciendo el cumsum de un vextor con VERDADERO en puntos de inicio)
FUN = cumsum
)
# Acumulado acotado de cierres parciales (CON ajuste por valores menores a -1)
BD$CIERRE_ACUM <- ifelse(BD$CIERRE_ACUM < -1,
-1,
BD$CIERRE_ACUM
)
BD$POS_ABIERTA <- ifelse(BD$DECISION_SIF == "OPEN",
1, # Si decisión es "OPEN"
ifelse(BD$DECISION_SIF == "CLOSE-OPEN", # Si decisiÓn NO es "OPEN"
1, # Si decisiÓn es "CLOSE-OPEN"
ifelse(BD$DECISION_SIF == "CLOSE", # Si decisiÓn NO es "OPEN" ni "CLOSE-OPEN"
0, # Si decisiÓn es "CLOSE"
ifelse(BD$DECISION_SIF == "HOLD POSITION", # Si decisiÓn es NO "OPEN" ni "CLOSE-OPEN" ni "CLOSE"
1 + BD$CIERRE_ACUM, # Si decisiÓn es "HOLD POSITION"
0 # Si decisiÓn es "NO POSITION"
)
)
)
)
BD$DECISION_FINAL <- ifelse(BD$DECISION_SIF == "HOLD POSITION",
ifelse(BD$POS_ABIERTA == 0,
ifelse(shift(BD$POS_ABIERTA, n=1, fill=NA) > 0,
"CLOSE",
"NO POSITION"
),
"HOLD POSITION"
),
BD$DECISION_SIF
)
BD$DECISION_FINAL <- ifelse(BD$DECISION_SIF == "HOLD POSITION",
ifelse(BD$POS_ABIERTA == 0,
ifelse(shift(BD$POS_ABIERTA, n=1, fill=NA) > 0,
"CLOSE",
"NO POSITION"
),
BD$DECISION_SIF # Es decir, "HOLD POSITION"
),
ifelse(BD$DECISION_SIF == "CLOSE",
ifelse(shift(BD$POS_ABIERTA == 0, n=1, fill=NA),
"NO POSITION",
BD$DECISION_SIF # Es decir, "CLOSE".
),
ifelse(BD$DECISION_SIF == "CLOSE-OPEN",
ifelse(shift(BD$POS_ABIERTA == 0, n=1, fill=NA),
"OPEN",
BD$DECISION_SIF # Es decir, "CLOSE-OPEN".
),
BD$DECISION_SIF # Es decir, "OPEN" o "NO POSITION"
)
)
)
